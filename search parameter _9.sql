--------- Session A
--Let’s create a new table called bank_accounts

CREATE TABLE bank_accounts (
    id INT GENERATED BY DEFAULT AS IDENTITY,
    name TEXT NOT NULL,
    balance INT NOT NULL,
    PRIMARY KEY(id)
);

--Insert values to the table

INSERT INTO bank_accounts(name, balance) 
VALUES('Charlie', 10000);

INSERT INTO bank_accounts(name, balance)
VALUES('Dora', 25000);

SELECT * FROM bank_accounts;

delete  from bank_accounts
where id=2;

update bank_accounts
set id =2
where id=3;

update bank_accounts
set balance =balance*2


SELECT * FROM bank_accounts;

--IMPORTANT: Click on the drop down next to the "run" button that we use to run commands and show that "Auto commit"

--------- Session B
 	--Performing a sequence of steps that needs to be done atomically in a transaction

--A group of statements surrounded by BEGIN and COMMIT is sometimes called a transaction block.

--Paste all the commands for Session A in and execute them in one go (no need to execute one-by-one)



BEGIN;

UPDATE bank_accounts
SET balance = balance - 100
WHERE name = 'Charlie';

UPDATE bank_accounts
SET balance = balance + 100
WHERE name = 'Dora';

COMMIT;

--Note that the amounts have been debited and credited atomically
SELECT * FROM bank_accounts;


 --Rolling back a transaction
--------Paste both commands in at one go and execute both at one go

INSERT INTO bank_accounts(name, balance)
VALUES('Jack', 1000);

SELECT * FROM bank_accounts;

--Rollback a transaction
--------Paste all the commands below so they can be seen in the same window


BEGIN;

UPDATE bank_accounts
SET balance = balance - 1500
WHERE name = 'Jack';

SELECT * FROM bank_accounts;

UPDATE bank_accounts
SET balance = balance + 1500
WHERE name = 'Dora';

SELECT * FROM bank_accounts;

ROLLBACK;

SELECT * FROM bank_accounts;

--Rolling back a committed transaction
--Paste all the commands below so they can be seen in the same window



-- Session A

BEGIN;

UPDATE bank_accounts
SET balance = balance - 900
WHERE name = 'Jack';

SELECT * FROM bank_accounts;

UPDATE bank_accounts
SET balance = balance + 900
WHERE name = 'Dora';

SELECT * FROM bank_accounts;

COMMIT;

ROLLBACK;

SELECT * FROM bank_accounts;


--The rollback command should give you a warning, no transaction in progress
--The table will also have the updates made
--Ie, we cannot rollback a committed transaction


avepoints

--Paste all the commands below so they can be seen in the same window



----- Session A


BEGIN;

INSERT INTO bank_accounts(name, balance)
VALUES('Julia', 100000);

SAVEPOINT inserted_julia;

SELECT * FROM bank_accounts;

UPDATE bank_accounts
SET balance = balance - 2000
WHERE name = 'Julia';

UPDATE bank_accounts
SET balance = balance + 2000
WHERE name = 'Jack';

SELECT * FROM bank_accounts;

ROLLBACK TO SAVEPOINT inserted_julia;

SELECT * FROM bank_accounts;

ROLLBACK;

SELECT * FROM bank_accounts;


--After rolling back to the savepoint you should be able to see Julia in the bank_accounts

--After rolling back completely you should see only the original 3 records Charlie, Dora, Jack

-----------------------Part 6 ---------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

--Transaction isolation levels READ COMMITTED by default

--Here we will use both Session A and Session B




--First only select BEGIN and the INSERT COMMAND and run

BEGIN;

INSERT INTO bank_accounts(name, balance)
VALUES('Nancy', 15000);


--Run in the current session (you should be able to see the record for Nancy)

SELECT * FROM bank_accounts;


------- Session B

--You should not be able to see the record for Nancy

SELECT * FROM bank_accounts;


-- ----- Session A

--Commit the transaction

COMMIT;


----- Session B

--After commit you should now be able to see the record for Nancy

SELECT * FROM bank_accounts;


-------------------------------------------------------------------------------------------------------------
--Part 7 ---------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------


--REPEATABLE READ



------- Session A
--Paste both commands in and just hit the play button to run all


BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;

SELECT * FROM bank_accounts;


--We see the data present


------- Session B
---Paste in all commands and just hit the play button to execute all


BEGIN;

UPDATE bank_accounts 
SET balance = 10000
WHERE name = 'Jack';

COMMIT;

SELECT * FROM bank_accounts;


--The balance for Jack should be 10000


------- Session A
--Execute the commands by selecting and running one at a time


SELECT * FROM bank_accounts;

COMMIT;


--Multiple reads in the same transaction got different results 


--------


--To avoid this we can use repeatable read isolation level

------- Session A
--Paste both commands in and just hit the play button to run all

BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

SELECT * FROM bank_accounts;

-- We see the balance is now 10000 for Jack


------- Session B
--Paste all commands in and just hit the play button to run all

BEGIN;

UPDATE bank_accounts 
SET balance = 20000
WHERE name = 'Jack';

COMMIT;

SELECT * FROM bank_accounts;
--We see the balance is now 20000 for Jack



------ Session A




SELECT * FROM bank_accounts;

--We see the balance did not change in Session A tt is still 10000 for Jack

--Now let's commit and see in Session A

--Paste both commands, select both, and run both


COMMIT;

SELECT * FROM bank_accounts;

# We see now the balance is changed to 20000

-------------------------------------------------------------------------------------------------------------
--Part 8 ---------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------


-- SERIALIZABLE
--Concurrent changes should be blocked and for that we can use serialization isolation level


-- Let's begin a transaction and update the balance for Nancy


------- Session A
--Paste all commands in and just hit the play button to run all

BEGIN;

UPDATE bank_accounts 
SET balance = 0
WHERE name = 'Nancy';

SELECT * FROM bank_accounts;

--We see the balance is updated Nancy should have 0 balance


------- Session B
--Paste all commands in and just hit the play button to run all


BEGIN;


UPDATE bank_accounts 
SET balance = 100000
WHERE name = 'Nancy';

SELECT * FROM bank_accounts;


--We see the update statement is not completed
--The query runs for a long time till we commit the transaction in Session A


--Go back to Session A and commit

------- Session A


COMMIT;


------ Session B

--Now check the query in Session B we see the query has run successfully
--This is because PostgreSQL places a lock to prevent another update until the first transaction is finished

--Now commit the second session's transaction (add this command to the very bottom, select, and run)

COMMIT;

SELECT * FROM bank_accounts;

# Now if we check Nancy's balance it is 10000 and not 0
# So the first transaction’s change is lost, because the second one “overwrote” the row


---------------

# To avoid this let's use serialization


------- Session A
--Paste all commands in and just hit the play button to run all

BEGIN;

UPDATE bank_accounts 
SET balance = 0
WHERE name = 'Nancy';

SELECT * FROM bank_accounts;


--Here Nancy's balance should be 0



------- Session B
--Paste all commands in and just hit the play button to run all


BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;

UPDATE bank_accounts 
SET balance = 100000
WHERE name = 'Nancy';

SELECT * FROM bank_accounts;

--We see the query will not end

--Go back to Session A and commit

------- Session A


COMMIT;


-- Now check Session B and we see the query is not executed
-- It throws error:
--ERROR:  could not serialize access due to concurrent update